"""
This is an enhancement of PU Learners Module
This module provides classes for extracting features and deploying a PU
Learner model for predicting material synthesizability. 
"""


import os
import pandas as pd
import numpy as np
import logging


from monty.serialization import loadfn, dumpfn

from pymatgen.ext.matproj import MPRester

from pymatgen import Composition
import json
from pymatgen import Structure, Lattice
from pumml.learners import PULearner
from matminer.featurizers.structure import DensityFeatures, GlobalSymmetryFeatures
from matminer.featurizers.composition import Meredig, CohesiveEnergy
from pathlib import Path
import tarfile

# Extract Data from FigShare
os.system(
    "wget https://s3-eu-west-1.amazonaws.com/pfigshare-u-files/23873285/pupredict_data.tar.gz"
)
test_dir = os.getcwd()
# Extract file from the tar file
my_tar = tarfile.open("pupredict_data.tar.gz")
my_tar.extractall("Model_Data")  # specifing which folder to extract to
my_tar.close()

logging.basicConfig(
    filename="output.log", format="%(levelname)s - %(message)s", level=logging.DEBUG
)


class PUPredict:
    def _init_(self):
        """An extension of class PULearner which uses a machine learning
       model to predict synthesizability of all compounds in Materials Project
       Database


        Features for training data are generated by first-principles 
        (density functional theory) calculations, or structural or chemical
        data looked up from Materials Project Database


        Two models each for F-Block data and Non F-Block data have been pre-trained
        which are used to predict synthesizability of compounds based on the block
        they belong to. 


        Attributes:
            func_input (str, pymatgen.core.structure.Structure): Input to the fucntion

            api_key (str): valid api_key to access materials project database 
            mp_ids(list): Contains the materials project IDs of input samples
            df_input(DataFrame): Pandas DataFrame whcih conatains features from Materials Project Database of the input samples
            df_extracted(DataFrame): Pandas DataFrame which contains features of input samples extracted using Matminer 
            synth_scores (list): Synthesizability scores (between 0 and 1) of
                given sample.


        """
        self.func_input = None
        self.api_key = None

    def _mpr(self):
        """
        Setting the input API-Key into a function 
        Args:
            None
        Returns:
            MPRester(function): A function which is used to extract data from Materials Project 
      """
        return MPRester(api_key=self.api_key)

    def _get_mp_id(self, updated_input):
        """

       Gets the Materials IDs from the database

        Args:
            updated_input (criteria): The condition on which the data is extracted

        Returns:
            mp_ids (list): List of MP-IDs


      """

        criteria = updated_input

        # get mp-id
        mpids = []
        with self._mpr() as m:
            mp_ids = m.query(criteria, ["material_id"], chunk_size=0)

        mp_ids = [mpid["material_id"] for mpid in mp_ids]

        return mp_ids

    def _get_formula(self, updated_input):
        """

       Gets the full formula from Materials Project

        Args:
            updated_input (criteria): The condition on which the data is extracted

        Returns:
            formula (str): A string which contains the formula of the input


      """
        criteria = updated_input

        formula = []

        # get formualae
        with self._mpr() as m:
            formula = m.query(criteria, ["full_formula"], chunk_size=0)

        formula = [id["full_formula"] for id in formula]

        return formula[0]

    def _get_data(self, mp_ids):
        """

       Gets features of the Materials IDs from the database

        Args:
            mp_ids (list): List of MP-IDs

        Returns:
            df_input(DataFrame): Pandas DataFrame whcih conatains features from Materials Project Database of the input samples


      """
        chunk_size = 1000
        sublists = [
            mp_ids[i : i + chunk_size] for i in range(0, len(mp_ids), chunk_size)
        ]
        # MPRester.supported_properties
        properties = [
            "theoretical",
            "energy_per_atom",
            "formation_energy_per_atom",
            "e_above_hull",
            "icsd_ids",
            "material_id",
            "structure",
        ]

        data = []
        # Get all materials from MP by mpid
        with self._mpr() as m:
            for sublist in sublists:
                data += m.query(
                    {"material_id": {"$in": sublist}}, properties=properties
                )

        df_input = pd.DataFrame(data)

        # PU_label is 1 (0) if experimental crystal structure exists (doesn't exist)
        df_input["PU_label"] = df_input.theoretical.apply(
            lambda x: 0 if x == True else 1
        )

        return df_input

    def _check_for_block(self, comp):
        """

       Check whehther it belongs to F-Block or Non F-Block. If the compound contains even one element from F-block, then the compound is 
       termed ad F-block compound, else it is termed as Non F-Block compound

        Args:
            comp (pymatgen.core.composition.Composition): Contains the composition of the the input sample

        Returns:
            fblock (boolean value): 0 if it belongs to F-block, 1 if it belongs to non-fblock


      """
        # check which block it belongs to
        if comp.contains_element_type("f-block") == True:
            return 0  # Belongs to F-block
        else:
            return 1  # Belongs to Non F-block

    def _check_for_theoretical(self, updated_input):
        """

       Check if the input is theortical or experimental and drop the experimental compounds

        Args:
            updated_input (criteria): The condition on which the data is extracted

        Returns:
            mp_ids (list): List of MP-IDs
            df_input(DataFrame): Pandas DataFrame whcih conatains features from Materials Project Database of the input samples


      """
        # Get Mp-IDs
        mp_id = self._get_mp_id(updated_input)

        # Get Features of input
        df_input = self._get_data(mp_id)

        # Print the MP-ID for experimental compounds
        for idx, elem in enumerate(mp_id):
            if df_input.theoretical.values[idx] == False:
                logging.info(
                    'The given input with material_id "%s" exists.',
                    df_input.material_id.values[idx],
                )
        # Update the df_input by removing experimental compounds
        j = df_input[(df_input.theoretical == False)].index
        df_input = df_input.drop(j)

        return mp_id, df_input

    def _check_if_already_exists(self, comp, updated_input):
        """

       Check if the input exists in pre-trained model

        Args:
            updated_input (criteria): The condition on which the data is extracted
            comp (pymatgen.core.composition.Composition): Contains the composition of the the input sample


        Returns:
            mp_ids (list): List of MP-IDs
            df_input(DataFrame): Pandas DataFrame whcih conatains features from Materials Project Database of the input samples
            fblock (boolean value): 0 if it belongs to F-block, 1 if it belongs to Non F block 
            synth_scores (list): Synthesizability scores (between 0 and 1) of
                given sample.


      """
        mp_id, df_input = self._check_for_theoretical(updated_input)
        fblock = self._check_for_block(comp)

        # Intialise Synthesizability Score
        synth_score = []

        # Load F-Block pre-trained Model
        if fblock == 0:
            fblock_trained = pd.read_json(
                test_dir
                + "/Model_Data/0384056001594797986/PUPredict_Data/fblock_trained_model.json"
            )
            mp_id_theo = df_input.material_id.values
            for i in mp_id_theo:
                if i in fblock_trained.material_id.values:
                    synth_score.append(
                        fblock_trained.synth_score[
                            fblock_trained.material_id == i
                        ].values
                    )
                    j = df_input[(df_input.material_id == i)].index
                    df_input = df_input.drop(j)

        # Load Non F-Block pre-trained Model
        elif fblock == 1:
            non_fblock_trained = pd.read_json(
                test_dir
                + "/Model_Data/0384056001594797986/PUPredict_Data/non_fblock_trained_model.json"
            )
            mp_id_theo = df_input.material_id.values
            for i in mp_id_theo:
                if i in non_fblock_trained.material_id.values:
                    synth_score.append(
                        non_fblock_trained.synth_score[
                            non_fblock_trained.material_id == i
                        ].values
                    )
                    j = df_input[(df_input.material_id == i)].index
                    df_input = df_input.drop(j)

        return fblock, mp_id, synth_score, df_input

    def _extract_features(df_input):
        """

       Extract features using Matminer from the 'structure' column in df_input

        Args:
            df_input(DataFrame): Pandas DataFrame whcih conatains features from Materials Project Database of the input samples


        Returns:
            df_extracted(DataFrame): Pandas DataFrame which contains features of input samples extracted using Matminer


      """
        # Dropping the 'theoretical' column
        df_input.drop(columns=["theoretical"], inplace=True)

        # Extracting the features
        dfeat = DensityFeatures()
        symmfeat = GlobalSymmetryFeatures()
        mfeat = Meredig()
        cefeat = CohesiveEnergy()

        df_input["density_test"] = df_input.structure.apply(
            lambda x: dfeat.featurize(x)[0]
        )
        df_input["vpa"] = df_input.structure.apply(lambda x: dfeat.featurize(x)[1])
        df_input["packing fraction"] = df_input.structure.apply(
            lambda x: dfeat.featurize(x)[2]
        )
        df_input["spacegroup_num"] = df_input.structure.apply(
            lambda x: symmfeat.featurize(x)[0]
        )
        df_input["cohesive_energy"] = df_input.apply(
            lambda x: cefeat.featurize(
                x.structure.composition,
                formation_energy_per_atom=x.formation_energy_per_atom,
            )[0],
            axis=1,
        )
        df_input["mean AtomicWeight"] = df_input.structure.apply(
            lambda x: mfeat.featurize(x.composition)[-17]
        )
        df_input["range AtomicRadius"] = df_input.structure.apply(
            lambda x: mfeat.featurize(x.composition)[-12]
        )
        df_input["mean AtomicRadius"] = df_input.structure.apply(
            lambda x: mfeat.featurize(x.composition)[-11]
        )
        df_input["range Electronegativity"] = df_input.structure.apply(
            lambda x: mfeat.featurize(x.composition)[-10]
        )
        df_input["mean Electronegativity"] = df_input.structure.apply(
            lambda x: mfeat.featurize(x.composition)[-9]
        )

        # Drop 'structure' column
        df_input.drop(columns=["structure"], inplace=True)

        # ignore compounds that failed to featurize
        df_extracted = df_input.fillna(df_input.mean()).query("cohesive_energy > 0.0")

        # Re-arranging the 'PU Label' column
        pu_label = df_extracted["PU_label"]
        df_extracted = df_extracted.drop(["PU_label"], axis=1)
        df_extracted["PU_label"] = pu_label

        # Drop the icsd_ids column
        df_extracted.drop(columns=["icsd_ids"], inplace=True)

        return df_extracted

    def _append_data(df_extracted, fblock):
        """

       Extract features using Matminer from the 'structure' column in df_input

        Args:
            df_extracted(DataFrame): Pandas DataFrame which contains features of input samples extracted using Matminer
            fblock (boolean value): 0 if it belongs to F-block, 1 if it belongs to Non F block


        Returns:
            df(DataFrame): Pandas DataFrame which contains features of input samples extracted using Matmimer along with training data
            input_ids(numpy array): MP-IDs of updated input compounds


      """
        # append data to the respective block
        input_ids = df_extracted.material_id.values

        # If it belongs to 'F-block'
        if fblock == 0:
            # F-Block training Dataset
            fblock_features = pd.read_json(
                test_dir
                + "/Model_Data/0384056001594797986/PUPredict_Data/fblock_extracted_features.json"
            )
            df = fblock_features.append(df_extracted)
            df.reset_index(drop=True, inplace=True)

        # If it belongs to 'Non F-Block'
        else:
            # Non F-Block training dataset
            non_fblock_features = pd.read_json(
                test_dir
                + "/Model_Data/0384056001594797986/PUPredict_Data/non_fblock_extracted_features.json"
            )
            df = non_fblock_features.append(df_extracted)
            df.reset_index(drop=True, inplace=True)

        return input_ids, df

    def _do_pulearner(input_ids, df):
        """

       Train the model using PULearner

        Args:
            df(DataFrame): Pandas DataFrame which contains features of input samples extracted using Matmimer along with training data
            input_ids(numpy array): MP-IDs of updated input compounds


        Returns:
            synth_scores (list): Synthesizability scores (between 0 and 1) of
                given sample.


      """

        # Run PUMML
        df.to_json("test.json")
        pul = PULearner()

        # Set hyperparameters
        n_splits = 10  # kfold CV
        n_repeats = 3  # Repeat the entire kfold CV n times for averaging
        n_bags = 100  # bags for bootstrap aggregating.

        pu_stats = pul.cv_baggingDT(
            "test.json", splits=n_splits, repeats=n_repeats, bags=n_bags
        )
        df1 = pul.df_U.copy()
        df1["synth_score"] = pu_stats["prob"]

        # Initialsing synth_score
        synth_score = []
        for i in range(len(input_ids)):
            synth_score.append(df1.synth_score[df1.material_id == input_ids[i]].values)

        return synth_score

    def material_id(self, func_input, api_key):

        """

       Takes input in form of material ID from materials project and returns the synthesizability score for the same.

        Args:
            func_input (str): Input to the fucntion should be in string format. For eg: 'mp-1234'
            api_key (str): valid api_key to access materials project database. Should be in string format. To get your api_key, head to https://materialsproject.org/open


        Returns:
            synth_scores (list): Synthesizability scores (between 0 and 1) of
                given sample.


      """
        # Updating the criteria
        updated_input = {"material_id": func_input}

        # Setting API_key for materials project
        self.api_key = api_key

        # Extracting formula
        formula = self._get_formula(updated_input)

        # Extracting composition
        comp = Composition(formula)

        # Extracting MP-IDs
        mp_id = self._get_mp_id(updated_input)

        # If Input given is invalid
        if len(mp_id) == 0:
            return "No such compound exists in Materials Project Database"

        # Checking if it already exists in pre-trained model
        fblock, mp_id, synth_score, df_input = self._check_if_already_exists(
            comp, updated_input
        )

        # If found in pre-trained models, report synth_scores
        if df_input.shape[0] == 0:
            if len(synth_score) != 0:
                logging.info("The synthesizability scores are %s", synth_score)
                return synth_score

        # Else, train the model and report scores
        else:
            df_extracted = self._extract_features(df_input)
            input_ids, df = self._append_data(df_extracted, fblock)
            score = self._do_pulearner(input_ids, df)
            synth_score.append(score)
            logging.info("The synthesizability scores are %s", synth_score)
            return synth_score

    def full_formula(self, func_input, api_key):
        """

       Takes input in form of full formula and returns the synthesizability score for the same.

        Args:
            func_input (str): Input to the fucntion should be in string format. For eg: 'Ba2Yb2Al4Si2N10O4'
            api_key (str): valid api_key to access materials project database. Should be in string format. To get your api_key, head to https://materialsproject.org/open


        Returns:
            synth_scores (list): Synthesizability scores (between 0 and 1) of
                given sample.


      """
        # Updating the criteria
        updated_input = {"full_formula": func_input}

        # Setting API Key
        self.api_key = api_key

        # Extracting the composition
        comp = Composition(func_input)

        # Extracting the MP-IDs
        mp_id = self._get_mp_id(updated_input)

        # If Input given is invalid
        if len(mp_id) == 0:
            return "No such compound exists in Materials Project Database"

        # Checking if it already exists in pre-trained model
        fblock, mp_id, synth_score, df_input = self._check_if_already_exists(
            comp, updated_input
        )

        # If found in pre-trained models, report synth_scores
        if df_input.shape[0] == 0:
            if len(synth_score) != 0:
                logging.info("The synthesizability scores are %s", synth_score)
                return synth_score

        # Else, train the model and report scores
        else:
            df_extracted = self._extract_features(df_input)
            input_ids, df = self._append_data(df_extracted, fblock)
            score = self._do_pulearner(input_ids, df)
            synth_score.append(score)
            logging.info("The synthesizability scores are %s", synth_score)
            return synth_score

    def pymatgen_structure(self, func_input, api_key):
        """

       Takes input in form of Pymatgen Structure Object and returns the synthesizability score for the same.

        Args:
            func_input (pymatgen.core.structure.Structure): Input to the fucntion should be in pymatgen.core.structure.Structure format. For more information, refer to test files
            api_key (str): valid api_key to access materials project database. Should be in string format. To get your api_key, head to https://materialsproject.org/open


        Returns:
            synth_scores (list): Synthesizability scores (between 0 and 1) of
                given sample.


      """
        # Setting API Key
        self.api_key = api_key

        # Extract formula and remove the spaces between them
        formula = func_input.formula
        formula = formula.replace(" ", "")

        # Extract the composition
        comp = Composition(formula)

        # Update the criteria
        updated_input = {"full_formula": formula}

        # Extract MP-IDs
        mp_id = self._get_mp_id(updated_input)

        # If Input given is invalid
        if len(mp_id) == 0:
            return "No such compound exists in Materials Project Database"

        # Checking if it already exists in pre-trained model
        fblock, mp_id, synth_score, df_input = self._check_if_already_exists(
            comp, updated_input
        )

        # If found in pre-trained models, report synth_scores
        if df_input.shape[0] == 0:
            if len(synth_score) != 0:
                logging.info("The synthesizability scores are %s", synth_score)
                return synth_score

        # Else, train the model and report scores
        else:
            df_extracted = self._check_if_already_exists(df_input)
            input_ids, df = self._append_data(df_extracted, fblock)
            score = self._do_pulearner(input_ids, df)
            synth_score.append(score)
            logging.info("The synthesizability scores are %s", synth_score)
            return synth_score
